%*******************************************************
% Abstract
%*******************************************************
%\renewcommand{\abstractname}{Abstract}
%\pdfbookmark[1]{Abstract}{Abstract}
\phantomsection
\addcontentsline{toc}{chapter}{\tocEntry{Abstract}}
\begingroup
\let\clearpage\relax
\let\cleardoublepage\relax
\let\cleardoublepage\relax

\chapter*{Abstract}
Rust is a new programming language developed by Mozilla in response to the fact
that C and C++ are unsafe, inefficient, and unergonomic --particularly when
applied to concurrency. Version 1.0 of Rust was released in May 2015, and appears
to be performing excellently. Rust code is memory-safe
by default, faster than C++, easier to maintain, and excels at concurrency.

Yet little analysis exists of the semantics and expressiveness of Rust's type
system. This thesis focuses on one of the core aspects of Rust's type system:
\emph{ownership}, a system for expressing where and when data lives, and
where and when data can be mutated.

In order to understand ownership and the problems it solves, we survey
several classical memory safety errors that ownership is effective at eliminating:
use-after-free, indexing out of bounds, iterator invalidation, and data races.
We also consider the problem of memory leaks, which ownership is useful for,
but insufficient to solve.

We observe that these problems are all related by the problem of regions of
code trusting data to uphold certain invariants. For instance, indexing out
of bounds occurs when one incorrectly trusts an index to agree with an array's
length. Since ownership is about controlling the mutation and lifetime of data,
it is therefore well-aligned for solving this kind of problem.

We demonstrate how ownership is useful for constructing safe and ergonomic
low-overhead abstractions, even when built upon unsafe foundations. For example,
iterators in Rust provide an interface for indexing into an array
without bounds checks while being statically immune to invalidation.
Two of these interfaces, \emph{drain} and \emph{entry}, were developed by us for Rust's
standard library.

We also survey some of the limits of ownership. In particular, we
explore how the lack of proper linear typing makes it difficult to guarantee
that desirable operations are performed, such as freeing unused memory or
repairing invariants. However we provide some tricks for \emph{ensuring} that operations
are performed (at the cost of ergonomics), or simply mitigating the impact of not
performing them.

Finally, we compare Rust's system of ownership to the similar systems found in
Cyclone and C++. These are the two closest systems to ownership in Rust
that we're aware of, and therefore merit some discussion.

\endgroup

\vfill
