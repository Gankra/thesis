\chapter{Limitations of Ownership}
\label{ch:limits}

TODO: this section needs to cleaned up and refactored (bitrot)
TODO: talk about thread::scoped?
TODO:

We've seen that ownership allows us to cleanly model several
problems, preventing incorrect usage without runtime overhead. In particular,
ownership is very good at preventing the use-after and view-invalidation
classes of errors. This is because ownership's primary role is to prevent data
from being accessed at inappropriate times. However ownership is unable to
properly model the opposite problem: \emph{requiring} data be accessed, as is the
case for leaks.

Leaks aren't well-modeled by ownership because Rust is based on \emph{affine}
semantics, which allow us to forget about values at any time.
In order to encode that a value must be properly consumed, we need to be able
to express that a value must be used \emph{exactly} once. Types with this property
are said to be \emph{linear}.

A poor-man's linear-typing can be acquired with \emph{destructors}. A value's destructor
is some code to execute when it goes out of scope. This effectively mandates that
values with destructors be used exactly once: the owner who decides to drop the
value on the ground is forced to invoke the value's destructor.

The most obvious limitation to this approach is that since destructors are implicitly invoked,
they cannot take any additional context. For instance, it may be desirable
to have a type that is allocated using a custom allocator, but does not store
a pointer to that allocator. The type therefore has insufficient information
to clean itself up, requiring the allocator be passed to it. A more robust linearity
system would allow us to encode this by requiring the destructor be explicitly invoked with
the allocator as an argument. Destructors also can't return anything to indicate
success or failure.

That said, destructors do a great job for many types. Collections and files
have a single ``natural'' final operation that requires no additional context.
Collections free their allocations and Files close their file descriptors.
Destructors also have the distinct advantage over more general linearity in that
they compose well with generic code. If some generic code wants to drop a value
on the ground, it can always do this knowing any linear requirements will be
satisfied by the destructor. Destructors provide a uniform interface with no
context required precisely \emph{because} they aren't general.

Unfortunately, ensuring that destructors execute is a nasty problem.
At the limit, hardware can fail and programs can abort. We just need to live
with that fact. For most resources this is actually fine; either the resources are
rendered irrelevant by the program ending, or the operating system will automatically
clean them all up itself.

Even accepting those circumstances, strict
linearity is a bit of a pain. In particular, it is desirable to be able to
create reference-counted cycles of types with destructors. Even if all references to
such a cycle are lost, it will keep itself alive, leaking the destructors
themselves. Further, it is sometimes desirable to manually prevent a destructor
from running, particularly when decomposing a value into its constituent parts. For
instance, one may wish to downgrade a pointer that would normally free its allocation
to a raw pointer, perhaps to pass to a C API.

There are various solutions to this problem, but most languages that include
destructors (C++, Rust, D, C\#, Java, ...) generally accept that sometimes
they won't run. They're convenient and generally
reliable, but if one \emph{really} needs something to happen, they can't always be
relied on. For Rust in particular, one can't pass a value with a destructor to
an arbitrary third-party and rely on the destructor to be called, even if
the borrows it held have expired.

As a concrete example, we can consider Rust's `drain` interface. `Drain` is a
utility for efficiently performing bulk removal from the middle of a growable
array. Arrays require their elements to be stored contiguously, so removing
from the middle of one generally requires the elements after it to be
shifted back to fill the hole. Doing this repeatedly is incredibly expensive,
so it's desirable to be able to defer the shift until we are done removing
elements. Doing this means the array is in an unsound state while the
removals are happening. We don't want this state to be observable by the client.

One solution to this problem is to require the caller to pass in a
destination buffer for all the elements that will be removed. Then `drain` can
just run to completion without ever yielding control to the client. Unfortunately,
this is quite inflexible.

To get more control we once again created an external interface, implementing
`drain` as an iterator. Elements are removed one at a time, allowing the user to
decide what is done with them without any need for allocating a buffer. At first
blush, the safety of this interface seems trivially solved by ownership. Drain is mutating the
array, so it contains a mutable reference to the array. That means the array is
inaccessible through any interface but the iterator while it exists. The
shifting can then be done in the iterator's destructor, which is exactly when
the borrow it holds expires. Perfect!

\begin{minted}{rust}
// A growable array with 5 numbers
let mut arr = vec![0, 1, 2, 3, 4];

// Drain out elements 1 to 3 (exclusive).
// The result of `drain` is an iterator
// that we pass to the for loop to drive.
for x in arr.drain(1..3) {
    // arr is statically inaccessible here
    println!("{}", x);
}
// backshifting is performed here
// arr is now accessible again

// 1 and 2 are now gone
assert_eq!(arr, vec![0, 3, 4]);
\end{minted}

Unfortunately, the soundness of this design relies on the user of our interface
allowing the destructor to run. No reasonable code would ever \emph{not} run the
destructor, but since one can violate memory safety by accessing these empty
indices, we cannot tolerate the possibility.

Thankfully, all is not lost. The solution to our problem is in fact quite simple.
Rather than relying on the destructor to put the array in a sound state,
we will \emph{start} the drain by putting the array into an incorrect but otherwise
sound state, and rely on the destructor to put the array into the correct state.
If the user of our interface prevents the destructor from running,
they'll get a poisoned array which will probably cause their program to behave
incorrectly, but be unable to violate memory safety.

In the case of `drain`, the poison is setting the length of the array to be zero.
The destructor in turn just sets the length to the correct value (which it would
have done anyway). So the overhead for this scheme is zeroing out a single
integer, which is completely negligible considering the operation we're performing.
The consequence of this poison is that all the elements in the array will be
lost if the destructor is leaked. There's a certain fairness to this: you leak me,
I leak you!

Not all interfaces have such a convenient poison though. If this is the case, one
may instead ensure some code executes by inverting the control. Instead of our
code having to execute in the user's function, we can require the user's code
to execute in ours. In the case of drain, we can require the user to pass a
function that will be passed a \emph{pointer} to the iterator, preventing them from
gaining true ownership of the iterator. We can then guarantee that the iterator's
destructor always runs by dropping it in our own function. In fact, because we
always control the value, we don't even need to use a destructor to ensure the
cleanup code runs.

\begin{minted}{rust}
let mut arr = vec![0, 1, 2, 3, 4];

// Drain out elements 1 to 3 (exclusive).
// `drain` has no result, but instead passes a
// pointer to a Drain iterator that it owns.
arr.drain(1..3, |iter| {
    // arr is statically inaccessible here
    for x in iter {
        println!("{}", x);
    }
}); // backshifting is performed once here
// arr is now accessible again

// 1 and 2 are now gone
assert_eq!(arr, vec![0, 3, 4]);
\end{minted}

This design is a bit less ergonomic and flexible, but it can easily cover the
common cases.

